/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.2002 from the
 * contents of Nodave.xs. Do not edit this file, edit Nodave.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "Nodave.xs"
/*
 PERL module to library function call translations.
 
 Part of Libnodave, a free communication libray for Siemens S7 200/300/400 via
 the MPI adapter 6ES7 972-0CA22-0XAC
 or  MPI adapter 6ES7 972-0CA23-0XAC
 or  TS adapter 6ES7 972-0CA33-0XAC
 or  MPI adapter 6ES7 972-0CA11-0XAC,
 IBH/MHJ-NetLink or CPs 243, 343 and 443
 
 (C) Thomas Hergenhahn (thomas.hergenhahn@web.de) 2005

 Libnodave is free software; you can redistribute it and/or modify
 it under the terms of the GNU Library General Public License as published by
 the Free Software Foundation; either version 2, or (at your option)
 any later version.

 Libnodave is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU Library General Public License
 along with Libnodave; see the file COPYING.  If not, write to
 the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  
*/

/*
    Changes: 05/15/06 applied bug fixes from H.-J. Beie. Thank you!
*/

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include "ppport.h"

#define LINUX
#include <nodave.h>

#include "const-c.inc"

typedef struct _daveInterface*	DaveInterface;
typedef struct _daveConnection*	DaveConnection;
typedef PDU*	DavePDU;
typedef daveResultSet*	DaveResultSet;

#line 58 "Nodave.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)	S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage		S_croak_xs_usage
#endif

#endif

#line 101 "Nodave.c"

/* INCLUDE:  Including 'const-xs.inc' from 'Nodave.xs' */


XS(XS_Nodave_constant); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_constant)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 4 "const-xs.inc"
#ifdef dXSTARG
	dXSTARG; /* Faster if we have it.  */
#else
	dTARGET;
#endif
	STRLEN		len;
        int		type;
	IV		iv;
	/* NV		nv;	Uncomment this if you need to return NVs */
	/* const char	*pv;	Uncomment this if you need to return PVs */
#line 130 "Nodave.c"
	SV *	sv = ST(0);
	const char *	s = SvPV(sv, len);
#line 18 "const-xs.inc"
        /* Change this to constant(aTHX_ s, len, &iv, &nv);
           if you need to return both NVs and IVs */
	type = constant(aTHX_ s, len, &iv);
      /* Return 1 or 2 items. First is error message, or undef if no error.
           Second, if present, is found value */
        switch (type) {
        case PERL_constant_NOTFOUND:
          sv =
	    sv_2mortal(newSVpvf("%s is not a valid Nodave macro", s));
          PUSHs(sv);
          break;
        case PERL_constant_NOTDEF:
          sv = sv_2mortal(newSVpvf(
	    "Your vendor has not defined Nodave macro %s, used",
				   s));
          PUSHs(sv);
          break;
        case PERL_constant_ISIV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHi(iv);
          break;
	/* Uncomment this if you need to return NOs
        case PERL_constant_ISNO:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHs(&PL_sv_no);
          break; */
	/* Uncomment this if you need to return NVs
        case PERL_constant_ISNV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHn(nv);
          break; */
	/* Uncomment this if you need to return PVs
        case PERL_constant_ISPV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHp(pv, strlen(pv));
          break; */
	/* Uncomment this if you need to return PVNs
        case PERL_constant_ISPVN:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHp(pv, iv);
          break; */
	/* Uncomment this if you need to return SVs
        case PERL_constant_ISSV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHs(sv);
          break; */
	/* Uncomment this if you need to return UNDEFs
        case PERL_constant_ISUNDEF:
          break; */
	/* Uncomment this if you need to return UVs
        case PERL_constant_ISUV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHu((UV)iv);
          break; */
	/* Uncomment this if you need to return YESs
        case PERL_constant_ISYES:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHs(&PL_sv_yes);
          break; */
        default:
          sv = sv_2mortal(newSVpvf(
	    "Unexpected return type %d while processing Nodave macro %s, used",
               type, s));
          PUSHs(sv);
        }
#line 207 "Nodave.c"
	PUTBACK;
	return;
    }
}


/* INCLUDE: Returning to 'Nodave.xs' from 'const-xs.inc' */


XS(XS_Nodave_daveStrerror); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveStrerror)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "code");
    {
	int	code = (int)SvIV(ST(0));
	char *	RETVAL;
	dXSTARG;
#line 57 "Nodave.xs"
    RETVAL=daveStrerror(code);
#line 233 "Nodave.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveSetDebug); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveSetDebug)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "level");
    {
	int	level = (int)SvIV(ST(0));
#line 66 "Nodave.xs"
	daveSetDebug(level);
#line 254 "Nodave.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Nodave_daveGetDebug); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveGetDebug)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 73 "Nodave.xs"
	RETVAL = daveGetDebug();
#line 275 "Nodave.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveNewInterface); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveNewInterface)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 6)
       croak_xs_usage(cv,  "r, w, name, y, x, z");
    {
	int	r = (int)SvIV(ST(0));
	int	w = (int)SvIV(ST(1));
	char *	name = (char *)SvPV_nolen(ST(2));
	int	y = (int)SvIV(ST(3));
	int	x = (int)SvIV(ST(4));
	int	z = (int)SvIV(ST(5));
	DaveInterface	RETVAL;
#line 90 "Nodave.xs"
	_daveOSserialType sif;
	sif.rfd=r;
	sif.wfd=w;
	RETVAL = daveNewInterface(sif,name,y,x,z);
#line 305 "Nodave.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "DaveInterface", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveNewConnection); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveNewConnection)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "di, y, x, z");
    {
	DaveInterface	di;
	int	y = (int)SvIV(ST(1));
	int	x = (int)SvIV(ST(2));
	int	z = (int)SvIV(ST(3));
	DaveConnection	RETVAL;

	if (sv_derived_from(ST(0), "DaveInterface")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    di = INT2PTR(DaveInterface,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveNewConnection",
			"di", "DaveInterface");
#line 105 "Nodave.xs"
	RETVAL = daveNewConnection(di,y,x,z);
#line 340 "Nodave.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "DaveConnection", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveGetResponse); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveGetResponse)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dc");
    {
	DaveConnection	dc;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "DaveConnection")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dc = INT2PTR(DaveConnection,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveGetResponse",
			"dc", "DaveConnection");
#line 114 "Nodave.xs"
	RETVAL = daveGetResponse(dc);	
#line 373 "Nodave.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveSendMessage); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveSendMessage)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "dc, p");
    {
	DaveConnection	dc;
	DavePDU	p;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "DaveConnection")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dc = INT2PTR(DaveConnection,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveSendMessage",
			"dc", "DaveConnection");

	if (sv_derived_from(ST(1), "DavePDU")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    p = INT2PTR(DavePDU,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveSendMessage",
			"p", "DavePDU");
#line 123 "Nodave.xs"
	RETVAL = daveSendMessage(dc, p);
#line 415 "Nodave.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveDumpPDU); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveDumpPDU)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "p");
    {
	DavePDU	p;

	if (sv_derived_from(ST(0), "DavePDU")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    p = INT2PTR(DavePDU,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveDumpPDU",
			"p", "DavePDU");
#line 131 "Nodave.xs"
    _daveDumpPDU(p);
#line 445 "Nodave.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Nodave_daveDump); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveDump)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "name, b, len");
    {
	char *	name = (char *)SvPV_nolen(ST(0));
	char *	b = (char *)SvPV_nolen(ST(1));
	int	len = (int)SvIV(ST(2));
#line 139 "Nodave.xs"
    _daveDump(name,b,len);
#line 467 "Nodave.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Nodave_daveBlockName); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveBlockName)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "bn");
    {
	int	bn = (int)SvIV(ST(0));
	char *	RETVAL;
	dXSTARG;
#line 145 "Nodave.xs"
	RETVAL = daveBlockName(bn);
#line 489 "Nodave.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveAreaName); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveAreaName)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "n");
    {
	int	n = (int)SvIV(ST(0));
	char *	RETVAL;
	dXSTARG;
#line 153 "Nodave.xs"
	RETVAL = daveAreaName(n);
#line 512 "Nodave.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveSwapIed_16); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveSwapIed_16)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ff");
    {
	short	ff = (short)SvIV(ST(0));
	short	RETVAL;
	dXSTARG;
#line 161 "Nodave.xs"
	RETVAL = daveSwapIed_16(ff);
#line 535 "Nodave.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveSwapIed_32); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveSwapIed_32)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ff");
    {
	int	ff = (int)SvIV(ST(0));
	int	RETVAL;
	dXSTARG;
#line 169 "Nodave.xs"
	RETVAL = daveSwapIed_32(ff);
#line 558 "Nodave.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveGetFloatAt); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveGetFloatAt)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "dc, pos");
    {
	DaveConnection	dc;
	int	pos = (int)SvIV(ST(1));
	float	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "DaveConnection")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dc = INT2PTR(DaveConnection,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveGetFloatAt",
			"dc", "DaveConnection");
#line 179 "Nodave.xs"
	RETVAL = daveGetFloatAt(dc,pos);
#line 591 "Nodave.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_toPLCfloat); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_toPLCfloat)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "f");
    {
	float	f = (float)SvNV(ST(0));
	float	RETVAL;
	dXSTARG;
#line 187 "Nodave.xs"
	RETVAL = toPLCfloat(f);
#line 614 "Nodave.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveToPLCfloat); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveToPLCfloat)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "f");
    {
	float	f = (float)SvNV(ST(0));
	int	RETVAL;
	dXSTARG;
#line 195 "Nodave.xs"
	RETVAL = daveToPLCfloat(f);
#line 637 "Nodave.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveGetS8from); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveGetS8from)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "buffer, pos");
    {
	char *	buffer = (char *)SvPV_nolen(ST(0));
	int	pos = (int)SvIV(ST(1));
	int	RETVAL;
	dXSTARG;
#line 205 "Nodave.xs"
	RETVAL = daveGetS8from(buffer+pos);
#line 661 "Nodave.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveGetU8from); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveGetU8from)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "buffer, pos");
    {
	char *	buffer = (char *)SvPV_nolen(ST(0));
	int	pos = (int)SvIV(ST(1));
	int	RETVAL;
	dXSTARG;
#line 215 "Nodave.xs"
	RETVAL = daveGetU8from(buffer+pos);
#line 685 "Nodave.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveGetS16from); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveGetS16from)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "buffer, pos");
    {
	char *	buffer = (char *)SvPV_nolen(ST(0));
	int	pos = (int)SvIV(ST(1));
	int	RETVAL;
	dXSTARG;
#line 225 "Nodave.xs"
	RETVAL = daveGetS16from(buffer+pos);
#line 709 "Nodave.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveGetU16from); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveGetU16from)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "buffer, pos");
    {
	char *	buffer = (char *)SvPV_nolen(ST(0));
	int	pos = (int)SvIV(ST(1));
	int	RETVAL;
	dXSTARG;
#line 235 "Nodave.xs"
	RETVAL = daveGetU16from(buffer+pos);
#line 733 "Nodave.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveGetS32from); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveGetS32from)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "buffer, pos");
    {
	char *	buffer = (char *)SvPV_nolen(ST(0));
	int	pos = (int)SvIV(ST(1));
	int	RETVAL;
	dXSTARG;
#line 245 "Nodave.xs"
	RETVAL = daveGetS32from(buffer+pos);
#line 757 "Nodave.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveGetU32from); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveGetU32from)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "buffer, pos");
    {
	char *	buffer = (char *)SvPV_nolen(ST(0));
	int	pos = (int)SvIV(ST(1));
	unsigned int	RETVAL;
	dXSTARG;
#line 255 "Nodave.xs"
	RETVAL = daveGetU32from(buffer+pos);
#line 781 "Nodave.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveGetFloatfrom); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveGetFloatfrom)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "buffer, pos");
    {
	char *	buffer = (char *)SvPV_nolen(ST(0));
	int	pos = (int)SvIV(ST(1));
	float	RETVAL;
	dXSTARG;
#line 265 "Nodave.xs"
	RETVAL = daveGetFloatfrom(buffer+pos);
#line 805 "Nodave.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveGetS8); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveGetS8)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dc");
    {
	DaveConnection	dc;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "DaveConnection")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dc = INT2PTR(DaveConnection,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveGetS8",
			"dc", "DaveConnection");
#line 274 "Nodave.xs"
	RETVAL = daveGetS8(dc);
#line 837 "Nodave.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveGetU8); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveGetU8)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dc");
    {
	DaveConnection	dc;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "DaveConnection")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dc = INT2PTR(DaveConnection,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveGetU8",
			"dc", "DaveConnection");
#line 283 "Nodave.xs"
	RETVAL = daveGetU8(dc);
#line 869 "Nodave.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveGetS16); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveGetS16)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dc");
    {
	DaveConnection	dc;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "DaveConnection")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dc = INT2PTR(DaveConnection,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveGetS16",
			"dc", "DaveConnection");
#line 293 "Nodave.xs"
	RETVAL = daveGetS16(dc);
#line 901 "Nodave.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveGetU16); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveGetU16)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dc");
    {
	DaveConnection	dc;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "DaveConnection")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dc = INT2PTR(DaveConnection,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveGetU16",
			"dc", "DaveConnection");
#line 303 "Nodave.xs"
	RETVAL = daveGetU16(dc);
#line 933 "Nodave.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveGetS32); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveGetS32)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dc");
    {
	DaveConnection	dc;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "DaveConnection")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dc = INT2PTR(DaveConnection,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveGetS32",
			"dc", "DaveConnection");
#line 313 "Nodave.xs"
	RETVAL = daveGetS32(dc);
#line 965 "Nodave.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveGetU32); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveGetU32)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dc");
    {
	DaveConnection	dc;
	unsigned int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "DaveConnection")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dc = INT2PTR(DaveConnection,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveGetU32",
			"dc", "DaveConnection");
#line 323 "Nodave.xs"
	RETVAL = daveGetU32(dc);
#line 997 "Nodave.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveGetFloat); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveGetFloat)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dc");
    {
	DaveConnection	dc;
	float	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "DaveConnection")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dc = INT2PTR(DaveConnection,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveGetFloat",
			"dc", "DaveConnection");
#line 333 "Nodave.xs"
	RETVAL = daveGetFloat(dc);
#line 1029 "Nodave.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveGetS8At); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveGetS8At)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "dc, pos");
    {
	DaveConnection	dc;
	int	pos = (int)SvIV(ST(1));
	float	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "DaveConnection")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dc = INT2PTR(DaveConnection,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveGetS8At",
			"dc", "DaveConnection");
#line 343 "Nodave.xs"
	RETVAL = daveGetS8At(dc,pos);
#line 1062 "Nodave.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveGetU8At); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveGetU8At)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "dc, pos");
    {
	DaveConnection	dc;
	int	pos = (int)SvIV(ST(1));
	float	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "DaveConnection")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dc = INT2PTR(DaveConnection,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveGetU8At",
			"dc", "DaveConnection");
#line 353 "Nodave.xs"
	RETVAL = daveGetU8At(dc,pos);
#line 1095 "Nodave.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveGetS16At); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveGetS16At)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "dc, pos");
    {
	DaveConnection	dc;
	int	pos = (int)SvIV(ST(1));
	float	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "DaveConnection")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dc = INT2PTR(DaveConnection,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveGetS16At",
			"dc", "DaveConnection");
#line 363 "Nodave.xs"
	RETVAL = daveGetS16At(dc,pos);
#line 1128 "Nodave.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveGetU16At); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveGetU16At)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "dc, pos");
    {
	DaveConnection	dc;
	int	pos = (int)SvIV(ST(1));
	float	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "DaveConnection")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dc = INT2PTR(DaveConnection,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveGetU16At",
			"dc", "DaveConnection");
#line 373 "Nodave.xs"
	RETVAL = daveGetU16At(dc,pos);
#line 1161 "Nodave.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveGetS32At); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveGetS32At)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "dc, pos");
    {
	DaveConnection	dc;
	int	pos = (int)SvIV(ST(1));
	float	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "DaveConnection")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dc = INT2PTR(DaveConnection,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveGetS32At",
			"dc", "DaveConnection");
#line 383 "Nodave.xs"
	RETVAL = daveGetS32At(dc,pos);
#line 1194 "Nodave.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveGetU32At); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveGetU32At)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "dc, pos");
    {
	DaveConnection	dc;
	int	pos = (int)SvIV(ST(1));
	float	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "DaveConnection")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dc = INT2PTR(DaveConnection,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveGetU32At",
			"dc", "DaveConnection");
#line 393 "Nodave.xs"
	RETVAL = daveGetU32At(dc,pos);
#line 1227 "Nodave.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveGetSeconds); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveGetSeconds)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dc");
    {
	DaveConnection	dc;
	float	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "DaveConnection")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dc = INT2PTR(DaveConnection,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveGetSeconds",
			"dc", "DaveConnection");
#line 402 "Nodave.xs"
	RETVAL = daveGetSeconds(dc);
#line 1259 "Nodave.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveGetSecondsAt); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveGetSecondsAt)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "dc, pos");
    {
	DaveConnection	dc;
	int	pos = (int)SvIV(ST(1));
	float	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "DaveConnection")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dc = INT2PTR(DaveConnection,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveGetSecondsAt",
			"dc", "DaveConnection");
#line 412 "Nodave.xs"
	RETVAL = daveGetSecondsAt(dc,pos);
#line 1292 "Nodave.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveGetCounterValue); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveGetCounterValue)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dc");
    {
	DaveConnection	dc;
	float	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "DaveConnection")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dc = INT2PTR(DaveConnection,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveGetCounterValue",
			"dc", "DaveConnection");
#line 421 "Nodave.xs"
	RETVAL = daveGetCounterValue(dc);
#line 1324 "Nodave.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveGetCounterValueAt); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveGetCounterValueAt)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "dc, pos");
    {
	DaveConnection	dc;
	int	pos = (int)SvIV(ST(1));
	float	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "DaveConnection")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dc = INT2PTR(DaveConnection,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveGetCounterValueAt",
			"dc", "DaveConnection");
#line 431 "Nodave.xs"
	RETVAL = daveGetCounterValueAt(dc,pos);
#line 1357 "Nodave.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveConnectPLC); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveConnectPLC)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dc");
    {
	DaveConnection	dc;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "DaveConnection")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dc = INT2PTR(DaveConnection,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveConnectPLC",
			"dc", "DaveConnection");
#line 443 "Nodave.xs"
	RETVAL = daveConnectPLC(dc);
#line 1389 "Nodave.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveReadBytes); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveReadBytes)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       croak_xs_usage(cv,  "dc, area, areaNumber, start, bytes");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	DaveConnection	dc;
	int	area = (int)SvIV(ST(1));
	int	areaNumber = (int)SvIV(ST(2));
	int	start = (int)SvIV(ST(3));
	int	bytes = (int)SvIV(ST(4));

	if (sv_derived_from(ST(0), "DaveConnection")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dc = INT2PTR(DaveConnection,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveReadBytes",
			"dc", "DaveConnection");
#line 456 "Nodave.xs"
	char buffer[1024];
	int rv;
	rv = daveReadBytes (dc, area, areaNumber, start, bytes, buffer);
	EXTEND(SP,2);
	PUSHs(sv_2mortal(newSVpvn(&buffer[0],bytes)));
	PUSHs(sv_2mortal(newSViv(rv)));
#line 1430 "Nodave.c"
	PUTBACK;
	return;
    }
}


XS(XS_Nodave_daveWriteBytes); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveWriteBytes)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 6)
       croak_xs_usage(cv,  "dc, area, areaNumber, start, bytes, buffer");
    {
	DaveConnection	dc;
	int	area = (int)SvIV(ST(1));
	int	areaNumber = (int)SvIV(ST(2));
	int	start = (int)SvIV(ST(3));
	int	bytes = (int)SvIV(ST(4));
	char*	buffer = (char *)SvPV_nolen(ST(5));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "DaveConnection")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dc = INT2PTR(DaveConnection,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveWriteBytes",
			"dc", "DaveConnection");
#line 474 "Nodave.xs"
	RETVAL = daveWriteBytes (dc, area, areaNumber, start, bytes, buffer);
#line 1467 "Nodave.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveReadBits); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveReadBits)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 4 || items > 5)
       croak_xs_usage(cv,  "dc, area, areaNumber, start, bytes=1");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	DaveConnection	dc;
	int	area = (int)SvIV(ST(1));
	int	areaNumber = (int)SvIV(ST(2));
	int	start = (int)SvIV(ST(3));
	int	bytes;

	if (sv_derived_from(ST(0), "DaveConnection")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dc = INT2PTR(DaveConnection,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveReadBits",
			"dc", "DaveConnection");

	if (items < 5)
	    bytes = 1;
	else {
	    bytes = (int)SvIV(ST(4));
	}
#line 487 "Nodave.xs"
	char buffer[1024];
	int rv;
	rv = daveReadBits (dc, area, areaNumber, start, bytes, buffer);
//	rv = daveReadBits (dc, area, areaNumber, start, bytes, NULL);
	EXTEND(SP,2);
	PUSHs(sv_2mortal(newSVpvn(&buffer[0],bytes)));
	PUSHs(sv_2mortal(newSViv(rv)));
#line 1515 "Nodave.c"
	PUTBACK;
	return;
    }
}


XS(XS_Nodave_daveWriteBits); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveWriteBits)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 6)
       croak_xs_usage(cv,  "dc, area, areaNumber, start, bytes, buffer");
    {
	DaveConnection	dc;
	int	area = (int)SvIV(ST(1));
	int	areaNumber = (int)SvIV(ST(2));
	int	start = (int)SvIV(ST(3));
	int	bytes = (int)SvIV(ST(4));
	char *	buffer = (char *)SvPV_nolen(ST(5));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "DaveConnection")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dc = INT2PTR(DaveConnection,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveWriteBits",
			"dc", "DaveConnection");
#line 505 "Nodave.xs"
	RETVAL = daveWriteBits (dc, area, areaNumber, start, bytes, buffer);
#line 1552 "Nodave.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveSetBit); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveSetBit)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       croak_xs_usage(cv,  "dc, area, DB, byteAdr, bitAdr");
    {
	DaveConnection	dc;
	int	area = (int)SvIV(ST(1));
	int	DB = (int)SvIV(ST(2));
	int	byteAdr = (int)SvIV(ST(3));
	int	bitAdr = (int)SvIV(ST(4));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "DaveConnection")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dc = INT2PTR(DaveConnection,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveSetBit",
			"dc", "DaveConnection");
#line 518 "Nodave.xs"
	RETVAL = daveSetBit (dc, area, DB, byteAdr, bitAdr);
#line 1588 "Nodave.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveClrBit); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveClrBit)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       croak_xs_usage(cv,  "dc, area, DB, byteAdr, bitAdr");
    {
	DaveConnection	dc;
	int	area = (int)SvIV(ST(1));
	int	DB = (int)SvIV(ST(2));
	int	byteAdr = (int)SvIV(ST(3));
	int	bitAdr = (int)SvIV(ST(4));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "DaveConnection")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dc = INT2PTR(DaveConnection,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveClrBit",
			"dc", "DaveConnection");
#line 531 "Nodave.xs"
	RETVAL = daveClrBit (dc, area, DB, byteAdr, bitAdr);
#line 1624 "Nodave.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveNewPDU); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveNewPDU)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	DavePDU	RETVAL;
#line 551 "Nodave.xs"
	RETVAL = daveNewPDU();
#line 1645 "Nodave.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "DavePDU", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveNewResultSet); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveNewResultSet)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	DaveResultSet	RETVAL;
#line 560 "Nodave.xs"
	RETVAL = daveNewResultSet();
#line 1667 "Nodave.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "DaveResultSet", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveInitAdapter); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveInitAdapter)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "di");
    {
	DaveInterface	di;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "DaveInterface")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    di = INT2PTR(DaveInterface,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveInitAdapter",
			"di", "DaveInterface");
#line 572 "Nodave.xs"
	RETVAL = daveInitAdapter(di);
#line 1700 "Nodave.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveDisconnectPLC); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveDisconnectPLC)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dc");
    {
	DaveConnection	dc;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "DaveConnection")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dc = INT2PTR(DaveConnection,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveDisconnectPLC",
			"dc", "DaveConnection");
#line 583 "Nodave.xs"
	RETVAL = daveDisconnectPLC(dc);
#line 1732 "Nodave.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveDisconnectAdapter); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveDisconnectAdapter)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "di");
    {
	DaveInterface	di;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "DaveInterface")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    di = INT2PTR(DaveInterface,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveDisconnectAdapter",
			"di", "DaveInterface");
#line 592 "Nodave.xs"
	RETVAL = daveDisconnectAdapter(di);
#line 1764 "Nodave.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveStop); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveStop)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dc");
    {
	DaveConnection	dc;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "DaveConnection")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dc = INT2PTR(DaveConnection,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveStop",
			"dc", "DaveConnection");
#line 607 "Nodave.xs"
	RETVAL = daveStop(dc);
#line 1796 "Nodave.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveStart); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveStart)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dc");
    {
	DaveConnection	dc;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "DaveConnection")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dc = INT2PTR(DaveConnection,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveStart",
			"dc", "DaveConnection");
#line 616 "Nodave.xs"
	RETVAL = daveStart(dc);
#line 1828 "Nodave.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_davePrepareReadRequest); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_davePrepareReadRequest)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "dc, p");
    {
	DaveConnection	dc;
	DavePDU	p;

	if (sv_derived_from(ST(0), "DaveConnection")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dc = INT2PTR(DaveConnection,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::davePrepareReadRequest",
			"dc", "DaveConnection");

	if (sv_derived_from(ST(1), "DavePDU")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    p = INT2PTR(DavePDU,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::davePrepareReadRequest",
			"p", "DavePDU");
#line 627 "Nodave.xs"
    davePrepareReadRequest(dc, p);
#line 1868 "Nodave.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Nodave_daveExecReadRequest); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveExecReadRequest)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "dc, p, rl");
    {
	DaveConnection	dc;
	DavePDU	p;
	DaveResultSet	rl;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "DaveConnection")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dc = INT2PTR(DaveConnection,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveExecReadRequest",
			"dc", "DaveConnection");

	if (sv_derived_from(ST(1), "DavePDU")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    p = INT2PTR(DavePDU,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveExecReadRequest",
			"p", "DavePDU");

	if (sv_derived_from(ST(2), "DaveResultSet")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    rl = INT2PTR(DaveResultSet,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveExecReadRequest",
			"rl", "DaveResultSet");
#line 637 "Nodave.xs"
	RETVAL = daveExecReadRequest(dc, p, rl);
#line 1919 "Nodave.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveUseResult); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveUseResult)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "dc, rl, n");
    {
	DaveConnection	dc;
	DaveResultSet	rl;
	int	n = (int)SvIV(ST(2));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "DaveConnection")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dc = INT2PTR(DaveConnection,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveUseResult",
			"dc", "DaveConnection");

	if (sv_derived_from(ST(1), "DaveResultSet")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    rl = INT2PTR(DaveResultSet,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveUseResult",
			"rl", "DaveResultSet");
#line 647 "Nodave.xs"
	RETVAL = daveUseResult(dc, rl, n);
#line 1962 "Nodave.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveFreeResults); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveFreeResults)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "rl");
    {
	DaveResultSet	rl;

	if (sv_derived_from(ST(0), "DaveResultSet")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    rl = INT2PTR(DaveResultSet,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveFreeResults",
			"rl", "DaveResultSet");
#line 655 "Nodave.xs"
	daveFreeResults(rl);
#line 1992 "Nodave.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Nodave_davePrepareWriteRequest); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_davePrepareWriteRequest)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "dc, p");
    {
	DaveConnection	dc;
	DavePDU	p;

	if (sv_derived_from(ST(0), "DaveConnection")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dc = INT2PTR(DaveConnection,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::davePrepareWriteRequest",
			"dc", "DaveConnection");

	if (sv_derived_from(ST(1), "DavePDU")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    p = INT2PTR(DavePDU,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::davePrepareWriteRequest",
			"p", "DavePDU");
#line 662 "Nodave.xs"
	davePrepareWriteRequest(dc, p);
#line 2031 "Nodave.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Nodave_daveAddVarToWriteRequest); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveAddVarToWriteRequest)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 6)
       croak_xs_usage(cv,  "p, area, DBnum, start, bytes, buffer");
    {
	DavePDU	p;
	int	area = (int)SvIV(ST(1));
	int	DBnum = (int)SvIV(ST(2));
	int	start = (int)SvIV(ST(3));
	int	bytes = (int)SvIV(ST(4));
	char*	buffer = (char *)SvPV_nolen(ST(5));

	if (sv_derived_from(ST(0), "DavePDU")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    p = INT2PTR(DavePDU,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveAddVarToWriteRequest",
			"p", "DavePDU");
#line 673 "Nodave.xs"
    daveAddVarToWriteRequest(p, area, DBnum, start, bytes, buffer);
#line 2065 "Nodave.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Nodave_daveAddBitVarToWriteRequest); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveAddBitVarToWriteRequest)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 6)
       croak_xs_usage(cv,  "p, area, DBnum, start, bytes, buffer");
    {
	DavePDU	p;
	int	area = (int)SvIV(ST(1));
	int	DBnum = (int)SvIV(ST(2));
	int	start = (int)SvIV(ST(3));
	int	bytes = (int)SvIV(ST(4));
	char*	buffer = (char *)SvPV_nolen(ST(5));

	if (sv_derived_from(ST(0), "DavePDU")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    p = INT2PTR(DavePDU,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveAddBitVarToWriteRequest",
			"p", "DavePDU");
#line 684 "Nodave.xs"
    daveAddBitVarToWriteRequest(p, area, DBnum, start, bytes, buffer);
#line 2099 "Nodave.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Nodave_daveAddVarToReadRequest); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveAddVarToReadRequest)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       croak_xs_usage(cv,  "p, area, DBnum, start, bytes");
    {
	DavePDU	p;
	int	area = (int)SvIV(ST(1));
	int	DBnum = (int)SvIV(ST(2));
	int	start = (int)SvIV(ST(3));
	int	bytes = (int)SvIV(ST(4));

	if (sv_derived_from(ST(0), "DavePDU")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    p = INT2PTR(DavePDU,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveAddVarToReadRequest",
			"p", "DavePDU");
#line 694 "Nodave.xs"
    daveAddVarToReadRequest(p, area, DBnum, start, bytes);
#line 2132 "Nodave.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Nodave_daveAddBitVarToReadRequest); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveAddBitVarToReadRequest)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       croak_xs_usage(cv,  "p, area, DBnum, start, bytes");
    {
	DavePDU	p;
	int	area = (int)SvIV(ST(1));
	int	DBnum = (int)SvIV(ST(2));
	int	start = (int)SvIV(ST(3));
	int	bytes = (int)SvIV(ST(4));

	if (sv_derived_from(ST(0), "DavePDU")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    p = INT2PTR(DavePDU,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveAddBitVarToReadRequest",
			"p", "DavePDU");
#line 704 "Nodave.xs"
    daveAddBitVarToReadRequest(p, area, DBnum, start, bytes);
#line 2165 "Nodave.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Nodave_setPort); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_setPort)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "port, baud, parity");
    {
	char*	port = (char *)SvPV_nolen(ST(0));
	char*	baud = (char *)SvPV_nolen(ST(1));
	char	parity = (char)*SvPV_nolen(ST(2));
	int	RETVAL;
	dXSTARG;
#line 713 "Nodave.xs"
	RETVAL = setPort(port, baud, parity);
#line 2189 "Nodave.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_openSocket); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_openSocket)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "port, peer");
    {
	int	port = (int)SvIV(ST(0));
	char*	peer = (char *)SvPV_nolen(ST(1));
	int	RETVAL;
	dXSTARG;
#line 723 "Nodave.xs"
	RETVAL = openSocket(port, peer);
#line 2213 "Nodave.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_closePort); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_closePort)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "port");
    {
	int	port = (int)SvIV(ST(0));
	int	RETVAL;
	dXSTARG;
#line 732 "Nodave.xs"
	RETVAL = closePort(port);
#line 2236 "Nodave.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_closeSocket); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_closeSocket)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "port");
    {
	int	port = (int)SvIV(ST(0));
	int	RETVAL;
	dXSTARG;
#line 741 "Nodave.xs"
	RETVAL = closeSocket(port);
#line 2259 "Nodave.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveGetTimeout); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveGetTimeout)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "di");
    {
	DaveInterface	di;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "DaveInterface")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    di = INT2PTR(DaveInterface,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveGetTimeout",
			"di", "DaveInterface");
#line 750 "Nodave.xs"
	RETVAL = daveGetTimeout(di);
#line 2291 "Nodave.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveSetTimeout); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveSetTimeout)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "di, time");
    {
	DaveInterface	di;
	int	time = (int)SvIV(ST(1));

	if (sv_derived_from(ST(0), "DaveInterface")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    di = INT2PTR(DaveInterface,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveSetTimeout",
			"di", "DaveInterface");
#line 760 "Nodave.xs"
	daveSetTimeout(di, time);
#line 2322 "Nodave.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Nodave_daveGetName); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveGetName)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "di");
    {
	DaveInterface	di;
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "DaveInterface")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    di = INT2PTR(DaveInterface,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveGetName",
			"di", "DaveInterface");
#line 767 "Nodave.xs"
	RETVAL = daveGetName(di);
#line 2353 "Nodave.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveGetAnswLen); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveGetAnswLen)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dc");
    {
	DaveConnection	dc;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "DaveConnection")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dc = INT2PTR(DaveConnection,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveGetAnswLen",
			"dc", "DaveConnection");
#line 776 "Nodave.xs"
	RETVAL = daveGetAnswLen(dc);
#line 2385 "Nodave.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveGetMaxPDULen); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveGetMaxPDULen)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dc");
    {
	DaveConnection	dc;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "DaveConnection")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dc = INT2PTR(DaveConnection,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveGetMaxPDULen",
			"dc", "DaveConnection");
#line 785 "Nodave.xs"
	RETVAL = daveGetMaxPDULen(dc);
#line 2417 "Nodave.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveGetMPIAdr); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveGetMPIAdr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dc");
    {
	DaveConnection	dc;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "DaveConnection")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dc = INT2PTR(DaveConnection,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveGetMPIAdr",
			"dc", "DaveConnection");
#line 794 "Nodave.xs"
	RETVAL = daveGetMPIAdr(dc);
#line 2449 "Nodave.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveGetErrorOfResult); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveGetErrorOfResult)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "drs, n");
    {
	DaveResultSet	drs;
	int	n = (int)SvIV(ST(1));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "DaveResultSet")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    drs = INT2PTR(DaveResultSet,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveGetErrorOfResult",
			"drs", "DaveResultSet");
#line 804 "Nodave.xs"
	RETVAL = daveGetErrorOfResult (drs, n);
#line 2482 "Nodave.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveForceDisconnectIBH); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveForceDisconnectIBH)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "di, src, dest, mpi");
    {
	DaveInterface	di;
	int	src = (int)SvIV(ST(1));
	int	dest = (int)SvIV(ST(2));
	int	mpi = (int)SvIV(ST(3));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "DaveInterface")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    di = INT2PTR(DaveInterface,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveForceDisconnectIBH",
			"di", "DaveInterface");
#line 816 "Nodave.xs"
	RETVAL = daveForceDisconnectIBH (di,src,dest,mpi);
#line 2517 "Nodave.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveForce200); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveForce200)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "dc, area, start, val");
    {
	DaveConnection	dc;
	int	area = (int)SvIV(ST(1));
	int	start = (int)SvIV(ST(2));
	int	val = (int)SvIV(ST(3));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "DaveConnection")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dc = INT2PTR(DaveConnection,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveForce200",
			"dc", "DaveConnection");
#line 828 "Nodave.xs"
	RETVAL = daveForce200 (dc, area, start, val);
#line 2552 "Nodave.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Nodave_daveGetOrderCode); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveGetOrderCode)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dc");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	DaveConnection	dc;

	if (sv_derived_from(ST(0), "DaveConnection")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dc = INT2PTR(DaveConnection,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveGetOrderCode",
			"dc", "DaveConnection");
#line 837 "Nodave.xs"
	char buffer[1024];
	int rv;
	rv = daveGetOrderCode(dc, buffer);
	EXTEND(SP,2);
	PUSHs(sv_2mortal(newSVpvn(&buffer[0],daveOrderCodeSize)));
	PUSHs(sv_2mortal(newSViv(rv)));
#line 2589 "Nodave.c"
	PUTBACK;
	return;
    }
}


XS(XS_Nodave_daveReadSZL); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveReadSZL)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "dc, ID, index");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	DaveConnection	dc;
	int	ID = (int)SvIV(ST(1));
	int	index = (int)SvIV(ST(2));

	if (sv_derived_from(ST(0), "DaveConnection")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dc = INT2PTR(DaveConnection,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveReadSZL",
			"dc", "DaveConnection");
#line 850 "Nodave.xs"
	char buffer[3000];
	int rv;
	rv = daveReadSZL(dc, ID, index, buffer, 3000);
	EXTEND(SP,2);
	PUSHs(sv_2mortal(newSVpvn(&buffer[0],daveOrderCodeSize)));
	PUSHs(sv_2mortal(newSViv(rv)));
#line 2628 "Nodave.c"
	PUTBACK;
	return;
    }
}


XS(XS_Nodave_daveListReachablePartners); /* prototype to pass -Wmissing-prototypes */
XS(XS_Nodave_daveListReachablePartners)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "di");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	DaveInterface	di;

	if (sv_derived_from(ST(0), "DaveInterface")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    di = INT2PTR(DaveInterface,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Nodave::daveListReachablePartners",
			"di", "DaveInterface");
#line 861 "Nodave.xs"
	char buffer[126];
	int rv;
	rv = daveListReachablePartners(di, buffer);
	EXTEND(SP,2);
	PUSHs(sv_2mortal(newSVpvn(&buffer[0],daveOrderCodeSize)));
	PUSHs(sv_2mortal(newSViv(rv)));
#line 2665 "Nodave.c"
	PUTBACK;
	return;
    }
}


XS(XS_DaveInterface_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_DaveInterface_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "di");
    {
	DaveInterface	di;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    di = INT2PTR(DaveInterface,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"DaveInterface::DESTROY",
			"di");
#line 873 "Nodave.xs"
//	printf("freeing DaveInterface %p\n",di);
	daveFree(di);
#line 2696 "Nodave.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_DaveConnection_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_DaveConnection_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dc");
    {
	DaveConnection	dc;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dc = INT2PTR(DaveConnection,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"DaveConnection::DESTROY",
			"dc");
#line 881 "Nodave.xs"
//	printf("freeing DaveConnection %p\n",dc);
	daveFree(dc);	
#line 2726 "Nodave.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_DavePDU_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_DavePDU_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dp");
    {
	DavePDU	dp;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dp = INT2PTR(DavePDU,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"DavePDU::DESTROY",
			"dp");
#line 889 "Nodave.xs"
//	printf("freeing DavePDU %p\n",dp);
	daveFree(dp);	
#line 2756 "Nodave.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_DaveResultSet_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_DaveResultSet_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "drs");
    {
	DaveResultSet	drs;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    drs = INT2PTR(DaveResultSet,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"DaveResultSet::DESTROY",
			"drs");
#line 897 "Nodave.xs"
//	printf("freeing DaveResultSet %p\n",drs);
	daveFreeResults(drs);
	daveFree(drs);	
#line 2787 "Nodave.c"
    }
    XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_Nodave); /* prototype to pass -Wmissing-prototypes */
XS(boot_Nodave)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    const char* file = __FILE__;

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    XS_VERSION_BOOTCHECK ;

        newXS("Nodave::constant", XS_Nodave_constant, file);
        newXSproto("Nodave::daveStrerror", XS_Nodave_daveStrerror, file, "$");
        newXSproto("Nodave::daveSetDebug", XS_Nodave_daveSetDebug, file, "$");
        newXSproto("Nodave::daveGetDebug", XS_Nodave_daveGetDebug, file, "");
        newXSproto("Nodave::daveNewInterface", XS_Nodave_daveNewInterface, file, "$$$$$$");
        newXSproto("Nodave::daveNewConnection", XS_Nodave_daveNewConnection, file, "$$$$");
        newXSproto("Nodave::daveGetResponse", XS_Nodave_daveGetResponse, file, "$");
        newXSproto("Nodave::daveSendMessage", XS_Nodave_daveSendMessage, file, "$");
        newXSproto("Nodave::daveDumpPDU", XS_Nodave_daveDumpPDU, file, "$");
        newXSproto("Nodave::daveDump", XS_Nodave_daveDump, file, "$$$");
        newXSproto("Nodave::daveBlockName", XS_Nodave_daveBlockName, file, "$");
        newXSproto("Nodave::daveAreaName", XS_Nodave_daveAreaName, file, "$");
        newXSproto("Nodave::daveSwapIed_16", XS_Nodave_daveSwapIed_16, file, "$");
        newXSproto("Nodave::daveSwapIed_32", XS_Nodave_daveSwapIed_32, file, "$");
        newXSproto("Nodave::daveGetFloatAt", XS_Nodave_daveGetFloatAt, file, "$$");
        newXSproto("Nodave::toPLCfloat", XS_Nodave_toPLCfloat, file, "$");
        newXSproto("Nodave::daveToPLCfloat", XS_Nodave_daveToPLCfloat, file, "$");
        newXSproto("Nodave::daveGetS8from", XS_Nodave_daveGetS8from, file, "$$");
        newXSproto("Nodave::daveGetU8from", XS_Nodave_daveGetU8from, file, "$$");
        newXSproto("Nodave::daveGetS16from", XS_Nodave_daveGetS16from, file, "$$");
        newXSproto("Nodave::daveGetU16from", XS_Nodave_daveGetU16from, file, "$$");
        newXSproto("Nodave::daveGetS32from", XS_Nodave_daveGetS32from, file, "$$");
        newXSproto("Nodave::daveGetU32from", XS_Nodave_daveGetU32from, file, "$$");
        newXSproto("Nodave::daveGetFloatfrom", XS_Nodave_daveGetFloatfrom, file, "$$");
        newXSproto("Nodave::daveGetS8", XS_Nodave_daveGetS8, file, "$");
        newXSproto("Nodave::daveGetU8", XS_Nodave_daveGetU8, file, "$");
        newXSproto("Nodave::daveGetS16", XS_Nodave_daveGetS16, file, "$");
        newXSproto("Nodave::daveGetU16", XS_Nodave_daveGetU16, file, "$");
        newXSproto("Nodave::daveGetS32", XS_Nodave_daveGetS32, file, "$");
        newXSproto("Nodave::daveGetU32", XS_Nodave_daveGetU32, file, "$");
        newXSproto("Nodave::daveGetFloat", XS_Nodave_daveGetFloat, file, "$");
        newXSproto("Nodave::daveGetS8At", XS_Nodave_daveGetS8At, file, "$$");
        newXSproto("Nodave::daveGetU8At", XS_Nodave_daveGetU8At, file, "$$");
        newXSproto("Nodave::daveGetS16At", XS_Nodave_daveGetS16At, file, "$$");
        newXSproto("Nodave::daveGetU16At", XS_Nodave_daveGetU16At, file, "$$");
        newXSproto("Nodave::daveGetS32At", XS_Nodave_daveGetS32At, file, "$$");
        newXSproto("Nodave::daveGetU32At", XS_Nodave_daveGetU32At, file, "$$");
        newXSproto("Nodave::daveGetSeconds", XS_Nodave_daveGetSeconds, file, "$$");
        newXSproto("Nodave::daveGetSecondsAt", XS_Nodave_daveGetSecondsAt, file, "$$");
        newXSproto("Nodave::daveGetCounterValue", XS_Nodave_daveGetCounterValue, file, "$$");
        newXSproto("Nodave::daveGetCounterValueAt", XS_Nodave_daveGetCounterValueAt, file, "$$");
        newXSproto("Nodave::daveConnectPLC", XS_Nodave_daveConnectPLC, file, "$");
        newXSproto("Nodave::daveReadBytes", XS_Nodave_daveReadBytes, file, "$$$$$");
        newXSproto("Nodave::daveWriteBytes", XS_Nodave_daveWriteBytes, file, "$$$$$$");
        newXSproto("Nodave::daveReadBits", XS_Nodave_daveReadBits, file, "$$$$;$");
        newXSproto("Nodave::daveWriteBits", XS_Nodave_daveWriteBits, file, "$$$$$$");
        newXSproto("Nodave::daveSetBit", XS_Nodave_daveSetBit, file, "$$$$$");
        newXSproto("Nodave::daveClrBit", XS_Nodave_daveClrBit, file, "$$$$$");
        newXSproto("Nodave::daveNewPDU", XS_Nodave_daveNewPDU, file, "");
        newXSproto("Nodave::daveNewResultSet", XS_Nodave_daveNewResultSet, file, "");
        newXSproto("Nodave::daveInitAdapter", XS_Nodave_daveInitAdapter, file, "$");
        newXSproto("Nodave::daveDisconnectPLC", XS_Nodave_daveDisconnectPLC, file, "$");
        newXSproto("Nodave::daveDisconnectAdapter", XS_Nodave_daveDisconnectAdapter, file, "$");
        newXSproto("Nodave::daveStop", XS_Nodave_daveStop, file, "$");
        newXSproto("Nodave::daveStart", XS_Nodave_daveStart, file, "$");
        newXSproto("Nodave::davePrepareReadRequest", XS_Nodave_davePrepareReadRequest, file, "$$");
        newXSproto("Nodave::daveExecReadRequest", XS_Nodave_daveExecReadRequest, file, "$$$");
        newXSproto("Nodave::daveUseResult", XS_Nodave_daveUseResult, file, "$$$");
        newXSproto("Nodave::daveFreeResults", XS_Nodave_daveFreeResults, file, "$");
        newXSproto("Nodave::davePrepareWriteRequest", XS_Nodave_davePrepareWriteRequest, file, "$$");
        newXSproto("Nodave::daveAddVarToWriteRequest", XS_Nodave_daveAddVarToWriteRequest, file, "$$$$$$");
        newXSproto("Nodave::daveAddBitVarToWriteRequest", XS_Nodave_daveAddBitVarToWriteRequest, file, "$$$$$$");
        newXSproto("Nodave::daveAddVarToReadRequest", XS_Nodave_daveAddVarToReadRequest, file, "$$$$$");
        newXSproto("Nodave::daveAddBitVarToReadRequest", XS_Nodave_daveAddBitVarToReadRequest, file, "$$$$$");
        newXSproto("Nodave::setPort", XS_Nodave_setPort, file, "$$$");
        newXSproto("Nodave::openSocket", XS_Nodave_openSocket, file, "$$");
        newXSproto("Nodave::closePort", XS_Nodave_closePort, file, "$");
        newXSproto("Nodave::closeSocket", XS_Nodave_closeSocket, file, "$");
        newXSproto("Nodave::daveGetTimeout", XS_Nodave_daveGetTimeout, file, "$");
        newXSproto("Nodave::daveSetTimeout", XS_Nodave_daveSetTimeout, file, "$$");
        newXSproto("Nodave::daveGetName", XS_Nodave_daveGetName, file, "$");
        newXSproto("Nodave::daveGetAnswLen", XS_Nodave_daveGetAnswLen, file, "$");
        newXSproto("Nodave::daveGetMaxPDULen", XS_Nodave_daveGetMaxPDULen, file, "$");
        newXSproto("Nodave::daveGetMPIAdr", XS_Nodave_daveGetMPIAdr, file, "$");
        newXSproto("Nodave::daveGetErrorOfResult", XS_Nodave_daveGetErrorOfResult, file, "$$");
        newXSproto("Nodave::daveForceDisconnectIBH", XS_Nodave_daveForceDisconnectIBH, file, "$$$$");
        newXSproto("Nodave::daveForce200", XS_Nodave_daveForce200, file, "$$$$");
        newXSproto("Nodave::daveGetOrderCode", XS_Nodave_daveGetOrderCode, file, "$");
        newXSproto("Nodave::daveReadSZL", XS_Nodave_daveReadSZL, file, "$$$");
        newXSproto("Nodave::daveListReachablePartners", XS_Nodave_daveListReachablePartners, file, "$");
        newXS("DaveInterface::DESTROY", XS_DaveInterface_DESTROY, file);
        newXS("DaveConnection::DESTROY", XS_DaveConnection_DESTROY, file);
        newXS("DavePDU::DESTROY", XS_DavePDU_DESTROY, file);
        newXS("DaveResultSet::DESTROY", XS_DaveResultSet_DESTROY, file);
    if (PL_unitcheckav)
         call_list(PL_scopestack_ix, PL_unitcheckav);
    XSRETURN_YES;
}

